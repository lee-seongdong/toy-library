# 전술적 설계 (Tactical Design)
바운디드 컨텍스트 내부를 어떻게 구현할 것인지 설계하는 기법

## 1. 주요 설계 관점
### 1.1. 속성 및 연산 관점
- 식별자, 불변성, 속성, 연산에 따라 엔티티와 값객체를 설계 -> 엔티티, 값 객체

### 1.2. 트랜잭션 및 일관성 관점
- 트랜잭션 범위를 고려하여, 바운디드 컨텍스트에 포함시킬 엔티티들 그룹핑 -> 애그리거트
- 애그리거트의 진입점이 되는 엔티티 식별 -> 애그리거트 루트
- 영속성 추상화 -> 리포지토리

> 설계기준
> - 함께 변경되는 객체들인가?
> - 트랜잭션 일관성이 필요한가?
> - 비즈니스 규칙을 공유하는가?

### 1.3. 로직 관점
- 엔티티나 값객체에 속하진 않지만, 애그리거트를 조작해야 하는 객체를 식별 -> 도메인 서비스

### 1.4. 객체 생성 관점
- 생성 과정이 복잡한 객체를 식별 -> 팩토리

### 1.5. 비즈니스 사건 관점
- 애그리거트에서 발생하는 이벤트 식별 -> 도메인 이벤트


## 2. 주요 산출물
### 2.1 엔티티 (Entity)
고유한 식별자를 가지며, 시간에 따라 속성이 변하는 도메인 객체

특징
- 동일성: 같은 식별자를 가지면 같은 객체
- 가변성: 속성이 변할 수 있음
- 생명주기: 생성 -> 변경 -> 소멸의 과정이 존재함

예시
```java
public class Member {
    private MemberId id;           // 식별자
    private String name;           // 변경 가능한 속성
    private Email email;           // 변경 가능한 속성
    private MemberStatus status;   // 상태 변화
    private LocalDateTime joinedAt; // 생성 시점
    
    // 비즈니스 행위 포함
    public void suspend(String reason) {
        if (this.status == MemberStatus.SUSPENDED) {
            throw new IllegalStateException("Already suspended");
        }
        this.status = MemberStatus.SUSPENDED;
        DomainEvents.raise(new MemberSuspended(this.id, reason));
    }
    
    public boolean canBorrow() {
        return status == MemberStatus.ACTIVE && !hasOverdueLoans();
    }
}
```

### 2.2 값 객체 (Value Object)
속성으로만 식별되며 도메인 개념을 표현하는 불변객체

특징
- 불변성: 객체 생성 후 변경 불가
- 등가성: 속성이 같으면 같은 객체
- 자가검증: 생성 시 유효성 검증
- 행위포함: 관련 비즈니스 로직 포함

예시
```java
public class ISBN {
    // 불변
    private final String value;
    
    // 자가 검증
    private ISBN(String value) {
        if (!isValidISBN(value)) {
            throw new IllegalArgumentException("Invalid ISBN format");
        }
        this.value = normalizeISBN(value);
    }
    
    public static ISBN of(String value) {
        return new ISBN(value);
    }
    
    // 비즈니스 로직 포함
    public boolean isElectronicFormat() {
        return value.startsWith("978");
    }
    
    // 등가성
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        ISBN isbn = (ISBN) obj;
        return Objects.equals(value, isbn.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
}
```

### 2.3 애그리거트 (Aggregate)
데이터 변경의 단위로 취급되는 연관 객체들의 군집  
애그리거트의 유일한 진입점이 되는 엔티티를 `애그리거트 루트`라고 함

특징
- 일관성 경계: 트랜잭션 범위와 일치
- 단일 진입점: 애그리거트 루트를 통해서만 접근
- 작은 크기: 꼭 필요한 객체만 포함
- ID참조: 다른 애그리거트는 ID로만 참조

애그리거트 루트의 역할
- 일관성 보장: 외부로 노출하는 범위를 최소화 하여 내부 일관성 유지
- 이벤트 발행: 도메인 이벤트를 발행하는 주체
- 비즈니스 규칙: 애그리거트 전체의 비즈니스 규칙을 정의

예시
```java
public class Loan {  // 애그리거트 루트
    private LoanId id;
    private MemberId memberId;        // 다른 애그리거트 ID 참조
    private BookId bookId;            // 다른 애그리거트 ID 참조
    private LoanPeriod period;        // 값 객체
    private List<LoanExtension> extensions; // 내부 엔티티
    private LoanStatus status;
    
    // 외부에서는 이 객체의 메서드들로만 접근
    public void borrow() {
        validateBorrowable();
        this.status = LoanStatus.ACTIVE;
        this.period = LoanPeriod.standardPeriod();
        
        DomainEvents.raise(new BookBorrowed(this.id, this.bookId, this.memberId));
    }
    
    public void extend(String reason) {
        if (!canExtend()) {
            throw new IllegalStateException("Cannot extend loan");
        }
        
        LoanExtension extension = new LoanExtension(reason);
        this.extensions.add(extension);
        this.period = this.period.extend(1);
    }
    
    // 내부 엔티티는 직접 노출하지 않음
    public int getExtensionCount() {
        return extensions.size();
    }
}

// 내부 엔티티 (외부에서 직접 접근 불가)
class LoanExtension {
    private LoanExtensionId id;
    private String reason;
    private LocalDateTime extendedAt;
    
    // 패키지 프라이빗
    LoanExtension(String reason) {
        this.id = LoanExtensionId.generate();
        this.reason = reason;
        this.extendedAt = LocalDateTime.now();
    }
}
```

### 2.4 도메인 서비스 (Domain Service)
엔티티나 값 객체이 속하지 않는 도메인 로직을 캡슐화 하는 객체

사용 시기
- 여러 애그리거트를 조합하여 새로운 비즈니스 로직을 생성하는 경우
- 복잡한 계산이나 알고리즘이 필요한 경우

특징
- 의존성을 가지지 않음
- 협업하는 도메인들을 매개변수로 받음

예시
```java
@DomainService
public class LoanDomainService {
    
    // 여러 애그리게이트 협업
    public void transferLoan(LoanId fromLoanId, MemberId toMemberId) {
        Loan loan = loanRepository.findById(fromLoanId);
        Member fromMember = memberRepository.findById(loan.getMemberId());
        Member toMember = memberRepository.findById(toMemberId);
        
        // 비즈니스 규칙 검증
        if (!fromMember.canTransferLoan(loan)) {
            throw new IllegalStateException("Cannot transfer loan");
        }
        if (!toMember.canReceiveLoan()) {
            throw new IllegalStateException("Member cannot receive loan");
        }
        
        // 도메인 로직 실행
        loan.transferTo(toMemberId);
        fromMember.removeLoan(fromLoanId);
        toMember.addLoan(fromLoanId);
    }
    
    // 복잡한 계산
    public Money calculateTotalOverdueFee(MemberId memberId) {
        List<Loan> overdueLoans = loanRepository.findOverdueByMember(memberId);
        return overdueLoans.stream()
            .map(Loan::calculateOverdueFee)
            .reduce(Money.ZERO, Money::add);
    }
}
```


### 2.5 리포지토리 인터페이스 (Repository)
애그리거트의 영속성을 추상화하는 인터페이스

특징
- 단일 리포지토리: 하나의 애그리거트당 하나의 리포지토리
- 도메인 계층: 인터페이스는 도메인 계층에 위치
- 구현 분리: 구현체는 인프라 계층에 위치

### 2.6 팩토리 (Factory)
복잡한 객체 생성 로직을 캡슐화 하는 객체  
생성 규칙이 자주 변경되거나 여러 객체를 조합해야 하는 경우에도 사용됨  


예시
```java
@Component
public class LoanFactory {
    
    public Loan createStandardLoan(MemberId memberId, BookId bookId) {
        validateLoanCreation(memberId, bookId);
        
        LoanId loanId = LoanId.generate();
        LoanPeriod period = LoanPeriod.standardPeriod(); // 2주
        
        return Loan.builder()
            .id(loanId)
            .memberId(memberId)
            .bookId(bookId)
            .period(period)
            .status(LoanStatus.PENDING)
            .build();
    }
    
    public Loan createExtendedLoan(MemberId memberId, BookId bookId, int weeks) {
        validateLoanCreation(memberId, bookId);
        validateExtendedPeriod(weeks);
        
        LoanId loanId = LoanId.generate();
        LoanPeriod period = LoanPeriod.of(weeks);
        
        return Loan.builder()
            .id(loanId)
            .memberId(memberId)
            .bookId(bookId)
            .period(period)
            .status(LoanStatus.PENDING)
            .build();
    }
    
    private void validateLoanCreation(MemberId memberId, BookId bookId) {
        // 복잡한 생성 규칙 검증
    }
}
```


### 2.7 도메인 이벤트 (Domain Event)
도메인에서 발생하는 비즈니스 사건을 표현하는 객체

특징
- 불변: 이미 발생한 사실이므로 불변
- 과거: 발생 시점은 과거이므로 과거형 네이밍
- 유비쿼터스 언어: 이벤트 또한 비즈니스 사건이므로, 유비쿼터스 언어 사용
- 최소화: 이벤트를 인지할 수 있을정도로 최소한의 정보만 포함

예시
```java
public class BookBorrowed implements DomainEvent {
    private final LoanId loanId;
    private final BookId bookId;
    private final MemberId memberId;
    private final LocalDateTime borrowedAt;
    private final LocalDateTime dueDate;
    
    public BookBorrowed(LoanId loanId, BookId bookId, MemberId memberId, 
                       LocalDateTime borrowedAt, LocalDateTime dueDate) {
        this.loanId = loanId;
        this.bookId = bookId;
        this.memberId = memberId;
        this.borrowedAt = borrowedAt;
        this.dueDate = dueDate;
    }
    
    @Override
    public LocalDateTime occurredOn() {
        return borrowedAt;
    }
    
    // getter methods...
}

// 이벤트 핸들러 예시
@EventListener
public class BookBorrowedHandler {
    
    public void handle(BookBorrowed event) {
        // 도서 상태 업데이트
        Book book = bookRepository.findById(event.getBookId());
        book.markAsBorrowed();
        bookRepository.save(book);
        
        // 알림 발송
        notificationService.sendBorrowConfirmation(
            event.getMemberId(), 
            event.getBookId(), 
            event.getDueDate()
        );
    }
}
```


## 3. 설계 원칙
### 3.1 애그리거트 설계 원칙
- 트랜잭션 일관성 경계
    - 하나의 애그리거트는 하나의 트랜잭션에서 수정
    - 여러 애그리거트를 한 트랜잭션에서 수정하면 안됨
- 작은 크기 유지
    - 관련 없는 데이터는 속성으로 두지 않는다.
- ID로만 다른 애그리거트 참조
    - 다른 객체 전체를 속성으로 가지지 않고, 식별자로만 참조한다.

### 3.2 도메인 로직 배치 원칙
- Tell, Don't Ask
```java
// Tell (시키기)
loan.checkOverdue();  // 객체에게 일을 시킴

// Don't Ask (묻고 처리)
if (loan.getStatus() == LoanStatus.ACTIVE && 
    loan.getDueDate().isBefore(LocalDateTime.now())) {
    loan.setStatus(LoanStatus.OVERDUE);
    loan.setOverdueFee(calculateFee(loan.getDaysOverdue()));
}
```

- 정보 전문가 패턴
```java
// 정보를 가진 객체가 책임을 가짐
class Loan {
    private LoanPeriod period;
    private LoanStatus status;
    
    // 대출 정보를 가진 Loan이 판단
    public boolean isOverdue() {  
        return period.isOverdue() && status == LoanStatus.ACTIVE;
    }
    
    // 대출 정보를 가진 Loan이 계산
    public Money calculateOverdueFee() {  
        if (!isOverdue()) {
            return Money.ZERO;
        }
        long overdueDays = period.getOverdueDays();
        return Money.of(overdueDays * 100, Currency.KRW);
    }
}
```

- 높은 응집도
```java
// 높은 응집도 - 관련된 데이터와 행위가 함께
class Member {
    private MemberId id;
    private Email email;
    private MemberGrade grade;
    private List<LoanId> currentLoans;
    
    // 회원 관련 모든 정보로 판단
    public boolean canBorrow() {  
        return grade.isActive() && 
               currentLoans.size() < grade.getMaxLoanCount() &&
               !hasSuspension();
    }
    
    // 회원의 책임
    public void borrowBook(BookId bookId) {  
        if (!canBorrow()) {
            throw new IllegalStateException("Cannot borrow book");
        }
        // 대출 로직
    }
}
```
- 낮은 결합도
```java
// 낮은 결합도 - 다른 애그리게이트와 느슨한 결합
class Loan {
    private MemberId memberId;  // ID로만 참조 (느슨한 결합)
    
    public void validateMember() {
        // 필요시에만 리포지토리를 통해 조회
        Member member = memberRepository.findById(memberId);
        if (!member.canBorrow()) {
            throw new IllegalStateException("Member cannot borrow");
        }
    }
}
```
- 단일 책임
```java
// 각 객체가 하나의 명확한 책임
class LoanCalculator {  // 계산 책임
    public Money calculateOverdueFee(Loan loan) { ... }
    public LocalDateTime calculateDueDate(LocalDateTime startDate) { ... }
}

class LoanValidator {  // 검증 책임
    public void validateBorrowable(Member member, Book book) { ... }
    public void validateReturnable(Loan loan) { ... }
}

class Loan {  // 대출 상태 관리 책임
    public void borrow() { ... }
    public void returnBook() { ... }
    public void extend() { ... }
}
```
