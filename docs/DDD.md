# Domain-Driven Design (DDD)

## 📚 **1단계: DDD 기본 개념 이해**
### 1.1 DDD란 무엇인가?
#### 1.1.1 전통적인 개발 방식의 문제점
#### 1.1.2 DDD의 등장 배경과 목적
#### 1.1.3 DDD의 핵심 철학

### 1.2 도메인(Domain)의 이해
#### 1.2.1 도메인이란?
#### 1.2.2 비즈니스 도메인 vs 기술 도메인
#### 1.2.3 도메인 전문가의 역할

### 1.3 모델(Model)의 역할
#### 1.3.1 도메인 모델이란?
#### 1.3.2 모델의 표현 방법
#### 1.3.3 모델과 구현의 관계

### 1.4 유비쿼터스 언어(Ubiquitous Language)
#### 1.4.1 공통 언어의 필요성
#### 1.4.2 유비쿼터스 언어 만들기
#### 1.4.3 코드에 언어 반영하기

## 🗺️ **2단계: 전략적 설계 (Strategic Design)**
### 2.1 도메인과 서브도메인 식별
#### 2.1.1 핵심 도메인(Core Domain) 찾기
#### 2.1.2 지원 서브도메인(Supporting Subdomain)
#### 2.1.3 일반 서브도메인(Generic Subdomain)
#### 2.1.4 서브도메인 분리 전략

### 2.2 바운디드 컨텍스트(Bounded Context)
#### 2.2.1 바운디드 컨텍스트란?
#### 2.2.2 컨텍스트 경계 설정하기
#### 2.2.3 컨텍스트 내 모델 통합

### 2.3 컨텍스트 맵(Context Map)
#### 2.3.1 컨텍스트 간 관계 매핑
#### 2.3.2 파트너십(Partnership)
#### 2.3.3 공유 커널(Shared Kernel)
#### 2.3.4 고객-공급자(Customer-Supplier)
#### 2.3.5 순응자(Conformist)
#### 2.3.6 안티코럽션 레이어(Anti-Corruption Layer)
#### 2.3.7 공개 호스트 서비스(Open Host Service)
#### 2.3.8 공표된 언어(Published Language)
#### 2.3.9 분리된 방법(Separate Ways)
#### 2.3.10 빅볼 오브 머드(Big Ball of Mud)

## 🔧 **3단계: 전술적 설계 기초 (Tactical Design Basics)**
### 3.1 엔티티(Entity)
#### 3.1.1 엔티티의 개념과 특징
#### 3.1.2 식별자(Identity) 설계
#### 3.1.3 엔티티 생명주기 관리
#### 3.1.4 엔티티 설계 원칙과 실습

### 3.2 값 객체(Value Object)
#### 3.2.1 값 객체의 개념과 특징
#### 3.2.2 불변성(Immutability) 구현
#### 3.2.3 등가성(Equality) 구현
#### 3.2.4 값 객체 설계 가이드라인과 실습

### 3.3 도메인 서비스(Domain Service)
#### 3.3.1 도메인 서비스가 필요한 경우
#### 3.3.2 엔티티 vs 값 객체 vs 도메인 서비스
#### 3.3.3 도메인 서비스 설계 원칙

## 🏗️ **4단계: 전술적 설계 고급 (Advanced Tactical Design)**
### 4.1 애그리게이트(Aggregate)
#### 4.1.1 애그리게이트의 개념과 목적
#### 4.1.2 애그리게이트 루트(Aggregate Root)
#### 4.1.3 일관성 경계(Consistency Boundary)
#### 4.1.4 애그리게이트 설계 원칙
#### 4.1.5 애그리게이트 간 참조 규칙
#### 4.1.6 애그리게이트 크기 결정하기

### 4.2 리포지토리(Repository)
#### 4.2.1 리포지토리 패턴의 목적
#### 4.2.2 애그리게이트별 리포지토리
#### 4.2.3 인터페이스와 구현 분리
#### 4.2.4 쿼리 메서드 설계

### 4.3 팩토리(Factory)
#### 4.3.1 복잡한 객체 생성 문제
#### 4.3.2 팩토리 메서드 vs 팩토리 클래스
#### 4.3.3 애그리게이트 팩토리 설계

## ⚡ **5단계: 도메인 이벤트와 비동기 처리**
### 5.1 도메인 이벤트(Domain Event)
#### 5.1.1 도메인 이벤트의 개념과 장점
#### 5.1.2 이벤트 설계 원칙
#### 5.1.3 이벤트 발행과 구독 구현

### 5.2 이벤트 스토밍(Event Storming)
#### 5.2.1 이벤트 스토밍 프로세스
#### 5.2.2 도메인 이벤트 발견하기
#### 5.2.3 애그리게이트 경계 찾기

### 5.3 사가 패턴(Saga Pattern)
#### 5.3.1 분산 트랜잭션 문제
#### 5.3.2 코레오그래피 vs 오케스트레이션
#### 5.3.3 보상 트랜잭션 설계

## 🏛️ **6단계: 아키텍처 패턴**
### 6.1 레이어드 아키텍처(Layered Architecture)
#### 6.1.1 레이어 구조와 책임
#### 6.1.2 프레젠테이션 레이어
#### 6.1.3 애플리케이션 레이어
#### 6.1.4 도메인 레이어
#### 6.1.5 인프라스트럭처 레이어
#### 6.1.6 의존성 방향과 문제점

### 6.2 헥사고날 아키텍처(Hexagonal Architecture)
#### 6.2.1 포트와 어댑터 패턴
#### 6.2.2 의존성 역전 원리 적용
#### 6.2.3 테스트 용이성 향상

### 6.3 클린 아키텍처(Clean Architecture)
#### 6.3.1 의존성 규칙
#### 6.3.2 엔티티와 유스케이스 분리
#### 6.3.3 인터페이스 어댑터 설계

## 📋 **7단계: 애플리케이션 서비스와 유스케이스**
### 7.1 애플리케이션 서비스
#### 7.1.1 애플리케이션 서비스의 역할과 책임
#### 7.1.2 도메인 서비스와의 차이점
#### 7.1.3 트랜잭션 관리
#### 7.1.4 보안과 권한 처리

### 7.2 명세(Specification) 패턴
#### 7.2.1 비즈니스 규칙 캡슐화
#### 7.2.2 조합 가능한 명세 설계
#### 7.2.3 쿼리 명세와 검증 명세

## 🔄 **8단계: CQRS와 이벤트 소싱**
### 8.1 CQRS (Command Query Responsibility Segregation)
#### 8.1.1 명령과 조회 분리의 필요성
#### 8.1.2 읽기 모델과 쓰기 모델 설계
#### 8.1.3 CQRS 구현 패턴
#### 8.1.4 CQRS의 장단점

### 8.2 이벤트 소싱(Event Sourcing)
#### 8.2.1 이벤트 소싱의 개념과 장점
#### 8.2.2 이벤트 스토어 설계
#### 8.2.3 스냅샷과 성능 최적화
#### 8.2.4 CQRS와 이벤트 소싱 결합

## 🌐 **9단계: 마이크로서비스와 DDD**
### 9.1 바운디드 컨텍스트와 서비스 경계
#### 9.1.1 컨텍스트별 서비스 분리
#### 9.1.2 데이터베이스 분리 전략
#### 9.1.3 서비스 간 통신 패턴

### 9.2 분산 시스템에서의 데이터 일관성
#### 9.2.1 최종 일관성(Eventual Consistency)
#### 9.2.2 분산 트랜잭션 대안
#### 9.2.3 데이터 동기화 전략

## 🛠️ **10단계: DDD 모델링 기법**
### 10.1 도메인 스토리텔링(Domain Storytelling)
#### 10.1.1 스토리텔링 프로세스
#### 10.1.2 액터와 워크 오브젝트 식별
#### 10.1.3 도메인 프로세스 시각화

### 10.2 예제 매핑(Example Mapping)
#### 10.2.1 규칙과 예제 발견
#### 10.2.2 질문과 가정 관리
#### 10.2.3 사용자 스토리 정제

### 10.3 사용자 스토리 매핑
#### 10.3.1 사용자 여정 매핑
#### 10.3.2 백로그 우선순위 결정
#### 10.3.3 MVP 범위 설정

## ⚠️ **11단계: DDD 안티패턴과 함정**
### 11.1 빈약한 도메인 모델(Anemic Domain Model)
#### 11.1.1 안티패턴 식별하기
#### 11.1.2 풍부한 도메인 모델로 전환
#### 11.1.3 행위 중심 설계

### 11.2 기타 주요 안티패턴
#### 11.2.1 스마트 UI 안티패턴
#### 11.2.2 트랜잭션 스크립트 남용
#### 11.2.3 과도한 엔지니어링

## 🚀 **12단계: DDD 실무 적용**
### 12.1 DDD 도입 전략
#### 12.1.1 조직의 준비도 평가
#### 12.1.2 점진적 도입 방법
#### 12.1.3 팀 교육과 문화 변화

### 12.2 레거시 시스템에 DDD 적용
#### 12.2.1 스트랭글러 패턴
#### 12.2.2 바운디드 컨텍스트 점진적 분리
#### 12.2.3 레거시 통합 전략

### 12.3 성공 사례와 실패 사례
#### 12.3.1 성공 요인 분석
#### 12.3.2 실패 원인과 교훈
#### 12.3.3 베스트 프랙티스

## 🔧 **13단계: DDD 구현과 도구**
### 13.1 Java/Spring 환경에서의 DDD
#### 13.1.1 Spring Boot와 DDD 아키텍처
#### 13.1.2 JPA와 애그리게이트 매핑
#### 13.1.3 Spring 이벤트와 도메인 이벤트

### 13.2 DDD 지원 라이브러리와 프레임워크
#### 13.2.1 Axon Framework
#### 13.2.2 EventStore
#### 13.2.3 기타 유용한 라이브러리

### 13.3 모델링과 문서화 도구
#### 13.3.1 Context Mapper
#### 13.3.2 PlantUML과 도메인 모델링
#### 13.3.3 협업 도구 활용
